# src/strategy/signal_filter.py
"""
This module filters trading signals to enforce minimum hold periods, confirmation by technical indicators,
and confidence thresholds. It also generates SMRT scalping signals as an additional signal source.

Key Integrations:
- **src.strategy.signal_generator**: Filters signals generated by signal_generator.py, ensuring they meet
  criteria like minimum hold periods and indicator confirmation.
- **src.strategy.indicators.calculate_atr**: Computes ATR for SMRT scalping signals.
- **src.constants.USE_SMRT_SCALPING**: Toggles SMRT scalping signal generation.
- **src.strategy.backtest_visualizer_ultimate**: Provides signal_data for filtering during backtesting.
- **src.data.data_preprocessor**: Uses preprocessed data with features like 'momentum_rsi', 'price_volatility'.

Future Considerations:
- Incorporate weights (e.g., from signal_manager.py) for confidence-based filtering of signals.
- Add support for additional filtering criteria (e.g., sentiment scores, market regime).
- Optimize vectorized operations for large datasets to improve performance.

Dependencies:
- pandas
- numpy
- typing.Dict
- src.strategy.indicators
- src.constants
"""

import logging
import pandas as pd
import numpy as np
from typing import Dict

from src.strategy.indicators import calculate_atr
from src.constants import USE_SMRT_SCALPING

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s')
signals_logger = logging.getLogger('signals')

def filter_signals(signal_df: pd.DataFrame, params: Dict = None) -> pd.DataFrame:
    """
    Vectorized filter for signals to enforce a minimum hold period and indicator confirmation.

    Args:
        signal_df (pd.DataFrame): DataFrame with signals and features, including:
            - signal: Trade signal (1 for buy, -1 for sell, 0 for hold).
            - signal_confidence: Confidence score for the signal.
            - momentum_rsi: RSI indicator.
            - price_volatility: Volatility measure.
            - trend_macd: MACD line.
            - macd_signal: MACD signal line (expected to be present from preprocessing).
            - close: Closing price.
        params (Dict, optional): Parameters for filtering, including:
            - rsi_buy_threshold: RSI threshold for buy signals.
            - rsi_sell_threshold: RSI threshold for sell signals.

    Returns:
        pd.DataFrame: Filtered DataFrame with updated 'signal' column.

    Notes:
        - Enforces a dynamic minimum hold period based on price volatility.
        - Requires confirmation from at least one indicator (RSI or MACD) and a minimum confidence.
        - Drops temporary columns used for filtering.
    """
    filtered_df = signal_df.copy()
    min_hold_period = 6
    min_confidence = 0.1

    params = params or {}
    rsi_buy_threshold = params.get('rsi_buy_threshold', 30)
    rsi_sell_threshold = params.get('rsi_sell_threshold', 70)

    required_cols = ['signal', 'signal_confidence', 'momentum_rsi', 'price_volatility', 'trend_macd', 'macd_signal']
    missing_cols = [col for col in required_cols if col not in filtered_df.columns]
    if missing_cols:
        signals_logger.warning(f"Missing columns for filtering: {missing_cols}. Some conditions may be skipped.")

    filtered_df['time_diff'] = filtered_df.index.to_series().diff().dt.total_seconds() / 3600
    filtered_df['cum_time'] = filtered_df['time_diff'].cumsum().fillna(0)
    filtered_df['dynamic_min_hold'] = np.where(filtered_df['price_volatility'] > filtered_df['price_volatility'].mean(), min_hold_period, 3)

    rsi_condition = (filtered_df['momentum_rsi'] < rsi_buy_threshold) & (filtered_df['signal'] == 1) | \
                    (filtered_df['momentum_rsi'] > rsi_sell_threshold) & (filtered_df['signal'] == -1)
    
    if 'trend_macd' in filtered_df.columns and 'macd_signal' in filtered_df.columns:
        macd_condition = (filtered_df['trend_macd'] > filtered_df['macd_signal']) & (filtered_df['signal'] == 1) | \
                        (filtered_df['trend_macd'] < filtered_df['macd_signal']) & (filtered_df['signal'] == -1)
    else:
        macd_condition = pd.Series(True, index=filtered_df.index)
        signals_logger.warning("MACD-based filtering skipped due to missing 'trend_macd' or 'macd_signal'.")
    
    confirming_indicators = (rsi_condition | macd_condition).astype(int) + \
                            (filtered_df['signal_confidence'] >= min_confidence).astype(int)

    filtered_df['signal_valid'] = (filtered_df['cum_time'] >= filtered_df['dynamic_min_hold'].shift(1, fill_value=0)) & \
                                 (filtered_df['signal'] != 0) & \
                                 (filtered_df['signal_confidence'] >= min_confidence) & \
                                 (confirming_indicators >= 1)
    filtered_df['signal'] = np.where(filtered_df['signal_valid'], filtered_df['signal'], 0)

    filtered_df.drop(columns=['time_diff', 'cum_time', 'dynamic_min_hold', 'signal_valid'], inplace=True)
    signals_logger.info(f"Filtered signals: Total valid signals = {(filtered_df['signal'] != 0).sum()}")
    return filtered_df

def smrt_scalping_signals(df: pd.DataFrame, atr_multiplier: float = 1.0, fee_rate: float = 0.001) -> pd.Series:
    """
    Generate scalping signals inspired by SMRT Algo with enhanced trend and volume confirmation.

    Args:
        df (pd.DataFrame): Preprocessed market data with columns 'high', 'low', 'close', 'volume'.
        atr_multiplier (float): Multiplier for ATR to determine price change thresholds (default: 1.0).
        fee_rate (float): Fee rate per trade for profitability check (default: 0.001).

    Returns:
        pd.Series: Series of signals (1 for buy, -1 for sell, 0 for hold), aligned with df.index.
    """
    if not USE_SMRT_SCALPING:
        signals_logger.info("SMRT Algo scalping signals disabled")
        return pd.Series(0, index=df.index, name='smrt_scalping_signal')

    try:
        # Validate required columns
        required_cols = ['high', 'low', 'close', 'volume']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            raise ValueError(f"Missing required columns: {missing_cols}")

        signals_logger.info(f"Starting SMRT Algo scalping signal computation for {len(df)} rows")

        # Ensure data is not empty and has no NaNs in required columns
        df = df[required_cols].copy()
        if df[required_cols].isna().any().any():
            signals_logger.warning("NaN values found in required columns, filling with forward/backward fill")
            df[required_cols] = df[required_cols].ffill().bfill()

        # Compute ATR
        atr = calculate_atr(df, period=14)
        signals_logger.debug(f"ATR computed: min={atr.min():.4f}, max={atr.max():.4f}, mean={atr.mean():.4f}")

        # Compute volatility
        volatility = df['close'].pct_change().rolling(window=20, min_periods=1).std().fillna(0)
        signals_logger.debug(f"Volatility computed: min={volatility.min():.4f}, max={volatility.max():.4f}, mean={volatility.mean():.4f}")

        # Compute dynamic multiplier
        volatility_mean = volatility.mean()
        if volatility_mean == 0:
            signals_logger.warning("Volatility mean is 0, setting dynamic multiplier to atr_multiplier")
            dynamic_multiplier = pd.Series(atr_multiplier, index=df.index)
        else:
            dynamic_multiplier = atr_multiplier * (1 + volatility / volatility_mean)
        signals_logger.debug(f"Dynamic multiplier computed: min={dynamic_multiplier.min():.4f}, max={dynamic_multiplier.max():.4f}")

        # Compute threshold
        threshold = (atr * dynamic_multiplier) / df['close']
        threshold = threshold.fillna(0)
        signals_logger.debug(f"Threshold computed: min={threshold.min():.4f}, max={threshold.max():.4f}")

        # Compute EMA for trend direction
        ema_short = df['close'].ewm(span=10, adjust=False).mean()
        trend_direction = np.where(df['close'] > ema_short, 1, -1)
        signals_logger.debug(f"Trend direction computed: {np.unique(trend_direction, return_counts=True)}")

        # Compute volume condition
        volume_sma = df['volume'].rolling(window=20, min_periods=1).mean()
        volume_condition = df['volume'] > volume_sma
        signals_logger.debug(f"Volume condition: {(volume_condition).sum()} true values")

        # Initialize signals
        signals = pd.Series(0, index=df.index, name='smrt_scalping_signal')

        # Compute price change
        price_change = df['close'].pct_change().fillna(0)
        signals_logger.debug(f"Price change computed: min={price_change.min():.4f}, max={price_change.max():.4f}")

        # Generate buy and sell conditions
        buy_condition = (price_change > threshold) & (df['close'] > df['close'].shift(1)) & \
                        (trend_direction == 1) & volume_condition
        sell_condition = (price_change < -threshold) & (df['close'] < df['close'].shift(1)) & \
                         (trend_direction == -1) & volume_condition

        # Ensure conditions are aligned with signals index
        buy_condition = buy_condition.reindex(signals.index).fillna(False)
        sell_condition = sell_condition.reindex(signals.index).fillna(False)

        signals[buy_condition] = 1
        signals[sell_condition] = -1
        signals_logger.debug(f"Initial signals: {signals.value_counts().to_dict()}")

        # Filter signals based on expected profit
        expected_profit = atr * atr_multiplier
        min_profit = df['close'] * fee_rate * 2
        signals[expected_profit < min_profit] = 0
        signals_logger.debug(f"Signals after profit filter: {signals.value_counts().to_dict()}")

        signals_logger.info(f"Generated SMRT Algo scalping signals: {signals.value_counts().to_dict()}")
        return signals

    except Exception as e:
        signals_logger.error(f"SMRT Algo scalping signals computation failed: {e}")
        return pd.Series(0, index=df.index, name='smrt_scalping_signal')